---
title: "An Introduction to Conda and Mamba on LS6"
subtitle: "Streamlining Scientific Computing with Effective Package Management"
author: "Rich Herrington"
format: 
  revealjs: 
    theme: white
    transition: slide
    self-contained: true
code-tools: true
incremental: true
---

## Conda for High-Performance Computing (HPC)
- Conda: An open-source package management and environment management system.
- Purpose: Facilitates the installation, management, and deployment of software packages and libraries.
- Cross-Platform: Available for Windows, macOS, and Linux.

## Conda in the Context of HPC
- Environment Management: Conda allows users to create isolated environments to manage dependencies and versions of software, ensuring consistency and reproducibility across different stages of the project and among different team members.
- Package Management: It simplifies the process of installing, updating, and managing software packages from various repositories, which can be crucial for managing complex HPC applications.

# Key Features Beneficial for HPC

## Reproducibility
- Ensures that computational experiments and applications are reproducible by managing specific versions of packages and dependencies.
- Facilitates sharing of environments using environment.yml files, ensuring that other researchers can recreate the same computational environment.

## Dependency Management
- Automatically resolves and manages dependencies, ensuring that all software libraries are compatible.
- Reduces the dependency problems by handling library versions and resolving conflicts, which is crucial in HPC where multiple libraries might be used for parallel computing, numerical analysis, data processing, etc.

## Cross-Language Support
- Supports various programming languages like Python, R, Julia, Scala, C/C++, SQL, etc., which are commonly used in data analysis, machine learning, scientific computing, and more in the HPC context.
- Allows for the integration of packages from different languages into a single computational environment, facilitating cross-language development and execution.

## Binary Package Management:
- Provides pre-compiled binary packages, which reduces the need to compile code and manage compilers, thereby simplifying software deployment on HPC systems.
- Provides binaries that are compatible with various CPU and GPU architectures, ensuring wide applicability in diverse HPC setups.
- Conda supports binary packages for Windows, macOS, and Linux, ensuring that software can be consistently deployed across various platforms.

## Channel and Repository Management:
- Allows users to access packages from different repositories and channels, providing a wide array of scientific and computational libraries and tools optimized for various use cases.
- Enables organizations to host their own repositories to manage and distribute software efficiently.

## Local Software Management 

- Conda allows users to create isolated environments, enabling the installation of software packages and dependencies without interfering with system-wide installations or requiring administrator privileges.
- Users can install software packages locally within a Conda environment, bypassing the need for system administrator permissions usually required for global installations.
- Conda provides access to pre-compiled binary packages, eliminating the need to compile software from source which might require system-level dependencies and administrator privileges.


## One Last Important Point About Performance

::: fragment
::: callout-warning 
Conda and its generic binary packages may not always provide the level of optimization and performance tuning that specialized HPC compilers and networking solutions can offer. The convenience and ease of use provided by Conda might come at the cost of potentially lower performance in some HPC scenarios. However, Conda still remains a valuable tool for managing and deploying software, especially in environments where ease of use, reproducibility, and rapid deployment are prioritized over squeezing out every last bit of performance.
:::
:::


# Installing Conda on LS6

## Download and Installation {.smaller style="font-size: 0.63em"}
 
1. Change into your work directory; then download the miniforge mamba/conda installer from the 
github site. [https://github.com/conda-forge/miniforge](https://github.com/conda-forge/miniforge)

::: {.fragment}
```bash
login1.ls6(672)$ pwd
/home1/07723/richherr
login2.ls6(549)$ cd /home1/07723/richherr/work
login1.ls6(658)$ wget "https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-$(uname)-$(uname -m).sh"
```
:::

2. Change the permissions on the installer to executable (+x).  
Then run the executable and follow the directions. Make sure to use the path to your **work** 
directory when installing. You don't want to install into your **home** directory.   

3. Respond **yes** the question: "Do you wish the installer to initialize Miniforge3
by running conda init? [yes|no]"

::: {.fragment}
```bash
login1.ls6(670)$ pwd
/home1/07723/richherr/work
login1.ls6(662)$ ls -la Miniforge3-Linux-x86_64.sh
-rw------- 1 richherr G-824114 87007851 Sep  3 18:22 Miniforge3-Linux-x86_64.sh
login1.ls6(663)$ chmod +x Miniforge3-Linux-x86_64.sh
login1.ls6(664)$ ls -la Miniforge3-Linux-x86_64.sh
-rwx------ 1 richherr G-824114 87007851 Sep  3 18:22 Miniforge3-Linux-x86_64.sh
login1.ls6(665)$ ./Miniforge3-Linux-x86_64.sh

Welcome to Miniforge3 23.3.1-1

In order to continue the installation process, please review the license
agreement.
Plea se, press ENTER to continue
>>>

```
:::

## Creating a <span style="color: red;">conda.init</span> File {.smaller style="font-size: 0.68em"}

4. We need to remove the conda lines added to your **.bashrc** file and place them in a
seperate file called **conda.init**.  We'll grab the last 20 lines to make sure we get 
all of the lines. We may need to delete some of the lines that are not part of the conda 
init lines. Use **nano** to edit the file.  Scroll through the file and **Ctl-k** (delete) 
any lines that are before the conda init lines then **Ctl-o** to save the file. Your **conda.init** 
file should contain something similar to the lines displayed using the **more** command.

::: {.fragment}
```bash
login2.ls6(564)$ cd ~
login2.ls6(564)$ tail -20 .bashrc > conda.init
login2.ls6(564)$ nano conda.init [delete any lines not contained within the conda init lines]
login2.ls6(564)$ more conda.init

## >>> conda initialize >>>
## !! Contents within this block are managed by 'conda init' !!
   __conda_setup="$('/work/07723/richherr/miniconda3/bin/conda' 'shell.bash' 'hook' 2> /dev/null
)"
   if [ $? -eq 0 ]; then
       eval "$__conda_setup"
   else
       if [ -f "/work/07723/richherr/miniconda3/etc/profile.d/conda.sh" ]; then
           . "/work/07723/richherr/miniconda3/etc/profile.d/conda.sh"
       else
           export PATH="/work/07723/richherr/miniconda3/bin:$PATH"
       fi
   fi
   unset __conda_setup
## <<< conda initialize <<<
```
:::

## Editing <span style="color: red;">.bashrc</span> and Activating Conda {style="font-size: 0.80em"}

5. Now we need to remove the conda init lines from our **.bashrc** file.  Use **nano** editor again 
to edit the **.bashrc** file.  Scroll to the bottom of the file and use **Ctl-k** to delete all of
the conda init lines (see lines above).  When finished use **Ctl-o** to save to your **.bashrc** file.  Now 
you can use the **source** command to source the **conda.init** file rather than having conda active
everytime you login to LS6. This gives you the ability to use **conda activate** in a bash shell. 

::: {.fragment}
```bash
login2.ls6(564)$ cd ~
login2.ls6(564)$ nano .bashrc [delete all of the conda init lines - see above]
login2.ls6(564)$ source conda.init
login2.ls6(564)$ conda activate
(base) login1.ls6(622)$ conda env list
# conda environments:
#
base                  *  /work/07723/richherr/miniconda3
>>>
```
:::














